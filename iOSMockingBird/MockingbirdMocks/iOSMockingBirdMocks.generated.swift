//
//  iOSMockingBirdMocks.generated.swift
//  iOSMockingBird
//
//  Generated by Mockingbird v0.11.1.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import iOSMockingBird
import Combine
import Foundation
import Swift
import SwiftUI
import UIKit

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AppDelegate

public final class AppDelegateMock: iOSMockingBird.AppDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "iOSMockingBird"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AppDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions)

  public override func `application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`connectingSceneSession`), Mockingbird.ArgumentMatcher(`options`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration {
      return concreteImplementation(`application`, `connectingSceneSession`, `options`)
    } else {
      return (implementation as! () -> UISceneConfiguration)()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `configurationForConnecting` `connectingSceneSession`: @escaping @autoclosure () -> UISceneSession, `options`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`connectingSceneSession`), Mockingbird.resolve(`options`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `configurationForConnecting` `connectingSceneSession`: UISceneSession, `options`: UIScene.ConnectionOptions) -> UISceneConfiguration", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, UISceneSession, UIScene.ConnectionOptions) -> UISceneConfiguration, UISceneConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>)

  public override func `application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`sceneSessions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIApplication, Set<UISceneSession>) -> Void {
      concreteImplementation(`application`, `sceneSessions`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didDiscardSceneSessions` `sceneSessions`: @escaping @autoclosure () -> Set<UISceneSession>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`sceneSessions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didDiscardSceneSessions` `sceneSessions`: Set<UISceneSession>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, Set<UISceneSession>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?)

  public override func `application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`application`), Mockingbird.ArgumentMatcher(`launchOptions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
      return concreteImplementation(`application`, `launchOptions`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `application`(_ `application`: @escaping @autoclosure () -> UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: @escaping @autoclosure () -> [UIApplication.LaunchOptionsKey: Any]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`application`), Mockingbird.resolve(`launchOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`application`(_ `application`: UIApplication, `didFinishLaunchingWithOptions` `launchOptions`: [UIApplication.LaunchOptionsKey: Any]?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `iOSMockingBird.AppDelegate`.
public func mock(_ type: iOSMockingBird.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock.InitializerProxy.Type {
  return AppDelegateMock.InitializerProxy.self
}

// MARK: - Mocked RestAPI

public final class RestAPIMock: iOSMockingBird.RestAPI, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "iOSMockingBird"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RestAPIMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `index`()

  public override func `index`() -> AnyPublisher<[String], URLError> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`index`() -> AnyPublisher<[String], URLError>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AnyPublisher<[String], URLError> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AnyPublisher<[String], URLError>)()
    }
  }

  public func `index`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AnyPublisher<[String], URLError>, AnyPublisher<[String], URLError>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`index`() -> AnyPublisher<[String], URLError>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AnyPublisher<[String], URLError>, AnyPublisher<[String], URLError>>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `iOSMockingBird.RestAPI`.
public func mock(_ type: iOSMockingBird.RestAPI.Type, file: StaticString = #file, line: UInt = #line) -> RestAPIMock {
  return RestAPIMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate

public final class SceneDelegateMock: iOSMockingBird.SceneDelegate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.1", "module_name": "iOSMockingBird"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SceneDelegateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked window

  override public var `window`: UIWindow? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> UIWindow?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (UIWindow?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWindow() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> UIWindow?, UIWindow?>(mock: self, invocation: invocation)
  }

  public func setWindow(_ newValue: @escaping @autoclosure () -> UIWindow?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "window.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (UIWindow?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions)

  public override func `scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`), Mockingbird.ArgumentMatcher(`session`), Mockingbird.ArgumentMatcher(`connectionOptions`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void {
      concreteImplementation(`scene`, `session`, `connectionOptions`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `scene`(_ `scene`: @escaping @autoclosure () -> UIScene, `willConnectTo` `session`: @escaping @autoclosure () -> UISceneSession, `options` `connectionOptions`: @escaping @autoclosure () -> UIScene.ConnectionOptions) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`), Mockingbird.resolve(`session`), Mockingbird.resolve(`connectionOptions`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`scene`(_ `scene`: UIScene, `willConnectTo` `session`: UISceneSession, `options` `connectionOptions`: UIScene.ConnectionOptions) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene, UISceneSession, UIScene.ConnectionOptions) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidBecomeActive`(_ `scene`: UIScene)

  public override func `sceneDidBecomeActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidBecomeActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidBecomeActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidDisconnect`(_ `scene`: UIScene)

  public override func `sceneDidDisconnect`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidDisconnect`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidDisconnect`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneDidEnterBackground`(_ `scene`: UIScene)

  public override func `sceneDidEnterBackground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneDidEnterBackground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneDidEnterBackground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillEnterForeground`(_ `scene`: UIScene)

  public override func `sceneWillEnterForeground`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneWillEnterForeground`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillEnterForeground`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `sceneWillResignActive`(_ `scene`: UIScene)

  public override func `sceneWillResignActive`(_ `scene`: UIScene) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scene`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UIScene) -> Void {
      concreteImplementation(`scene`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `sceneWillResignActive`(_ `scene`: @escaping @autoclosure () -> UIScene) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scene`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`sceneWillResignActive`(_ `scene`: UIScene) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UIScene) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `iOSMockingBird.SceneDelegate`.
public func mock(_ type: iOSMockingBird.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock.InitializerProxy.Type {
  return SceneDelegateMock.InitializerProxy.self
}
